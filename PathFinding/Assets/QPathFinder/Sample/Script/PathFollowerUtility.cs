#define WAYPOINT_MANAGER_ENABLE_DEBUG


using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace QPathFinder
{
    public static class PathFollowerUtility 
    {
		public enum SearchMode 
		{
			Simple = 0,
			Intermediate, 
			Complex
		}
		/* PUBLIC */

		public static void FindShortestPathBetweenNodesAsynchronous (  this PathFinder manager, int startNodeID, int endNodeID, PathLineType pathType, System.Action<List<Vector3>> OnPathFound )
		{
			int nearestPointFromStart = startNodeID;
			int nearestPointFromEnd = endNodeID;


			if ( nearestPointFromEnd == -1 || nearestPointFromStart == -1 )
			{
				Debug.LogError("ERROR. Could not find the path between " + nearestPointFromStart.ToString() + " and " + nearestPointFromEnd.ToString() );
				OnPathFound( null );
				return;
			}

			float startTime = Time.realtimeSinceStartup;
            
			manager.FindShortestPathAsynchronous( nearestPointFromStart, nearestPointFromEnd, 
				delegate ( List<Node> wayPoints ) 
                { 
					if ( wayPoints == null || wayPoints.Count == 0 )
						OnPathFound ( null );

					List<System.Object> allWayPoints	= new List<System.Object>();
                    string str = "";
                    if ( wayPoints != null )
                    {
                        foreach ( var a in wayPoints ) 
                        {
							allWayPoints.Add ( a.position );
							#if WAYPOINT_MANAGER_ENABLE_DEBUG
                            str += "=>" + a.autoGeneratedID.ToString();
							#endif
                        }
                    }
					#if WAYPOINT_MANAGER_ENABLE_DEBUG
                    Debug.LogWarning("Path: " + str);
                    Debug.Log("Time Taken:" + (Time.realtimeSinceStartup - startTime));
					#endif

					List<Vector3> path = null;
					
					{
						path = (pathType == PathLineType.Straight ? GetStraightPathPoints(allWayPoints) : GetCatmullRomCurvePathPoints ( allWayPoints ) );
					}

					#if WAYPOINT_MANAGER_ENABLE_DEBUG 
					for ( int i = 1; i < path.Count; i++ )
					{
						Debug.DrawLine(path[i - 1], path[i], Color.red, 10f);
					}
					#endif

					OnPathFound ( path );
                } );
		}

		public static void FindShortestPathBetweenPointsAsynchronous (  this PathFinder manager, Vector3 startPoint, Vector3 endPoint, PathLineType pathType, SearchMode searchMode,  System.Action<List<Vector3>> OnPathFound )
		{
			bool makeItMoreAccurate = searchMode == SearchMode.Intermediate || searchMode == SearchMode.Complex;
			int nearestPointFromStart = manager.FindNearestNode ( startPoint );
			int nearestPointFromEnd = -1;
			if ( nearestPointFromStart != -1 )
				nearestPointFromEnd = manager.FindNearestNode ( endPoint );


			if ( nearestPointFromEnd == -1 || nearestPointFromStart == -1 )
			{
				Debug.LogError("ERROR. Could not find the path between " + startPoint.ToString() + " and " + endPoint.ToString() );
				OnPathFound( null );
				return;
			}

			float startTime = Time.realtimeSinceStartup;
            
			manager.FindShortestPathAsynchronous( nearestPointFromStart, nearestPointFromEnd, 
				delegate ( List<Node> wayPoints ) 
                { 
					if ( wayPoints == null || wayPoints.Count == 0 )
						OnPathFound ( null );

					List<System.Object> allWayPoints	= new List<System.Object>();
                    string str = "";
                    if ( wayPoints != null )
                    {
                        foreach ( var a in wayPoints ) 
                        {
							allWayPoints.Add ( a );
							#if WAYPOINT_MANAGER_ENABLE_DEBUG
                            str += "=>" + a.autoGeneratedID.ToString();
							#endif
                        }
                    }
					#if WAYPOINT_MANAGER_ENABLE_DEBUG
                    Debug.LogWarning("Path: " + str);
                    Debug.Log("Time Taken:" + (Time.realtimeSinceStartup - startTime));
					#endif

					if ( makeItMoreAccurate )
					{
						if ( allWayPoints.Count > 1 ) 
						{
							bool tryOtherLines = false;
							int id = ((Node) allWayPoints[0]).autoGeneratedID;

							allWayPoints[0] = ComputeClosestPointFromPointToLine( startPoint, GetPositionFromNodeOrVector( allWayPoints, 0 ), GetPositionFromNodeOrVector( allWayPoints, 1 ), out tryOtherLines );

							if ( tryOtherLines ) 
							{
								allWayPoints.Insert(0, GetClosestPointOnAnyPath( id, manager, startPoint ) );
							}

							tryOtherLines = false;
							id = ((Node) allWayPoints[allWayPoints.Count - 1]).autoGeneratedID;
							allWayPoints[allWayPoints.Count - 1] = ComputeClosestPointFromPointToLine( endPoint, GetPositionFromNodeOrVector( allWayPoints, allWayPoints.Count - 2), GetPositionFromNodeOrVector( allWayPoints, allWayPoints.Count - 1), out tryOtherLines );

							if ( tryOtherLines ) 
							{
								allWayPoints.Add( GetClosestPointOnAnyPath( id, manager, endPoint ) );
							}
						}
						else 
							Debug.LogWarning ("Warning. Unable to get the best result due to less node count ");
					}
					else 
						Debug.Log ("Log. Simple calculations are used");

					List<Vector3> path = null;
					
					{
						allWayPoints.Insert ( 0, startPoint );
						allWayPoints.Add ( endPoint );

						path = (pathType == PathLineType.Straight ? GetStraightPathPoints(allWayPoints) : GetCatmullRomCurvePathPoints ( allWayPoints ) );
					}
					#if WAYPOINT_MANAGER_ENABLE_DEBUG 
					for ( int i = 1; i < path.Count; i++ )
					{
						Debug.DrawLine(path[i - 1], path[i], Color.red, 10f);
					}
					#endif

					OnPathFound ( path );
                } );
		}

		//public static PathFollower FollowPath( )

		public static PathFollower FollowPath( Transform transform, List<Vector3> points, float moveSpeed, PathLineType pathType = PathLineType.Straight )
		{
			var pathFollower = Create(transform);
			if (points != null) pathFollower.Follow(points, moveSpeed);
			else Debug.LogError(string.Format("[WaypointManager] couldn't find path"));
			return pathFollower;
		}
		public static PathFollower FollowPathWithGroundSnap( Transform transform, List<Vector3> points, float moveSpeed
																, Vector3 directionOfRayCast, float offsetDistanceFromPoint, float offsetDistanceToFloatFromGround, int maxDistanceForRayCast, int groundLayer
																, PathLineType pathType = PathLineType.Straight )
		{
			var pathFollower = CreateWithSnapToGround(transform, directionOfRayCast, offsetDistanceFromPoint, offsetDistanceToFloatFromGround, maxDistanceForRayCast, groundLayer );
			if (points != null) pathFollower.Follow(points, moveSpeed);
			else Debug.LogError(string.Format("[WaypointManager] couldn't find path"));
			return pathFollower;
		}
		public static void StopFollowing( Transform transform)
		{
			Stop(transform);
		}

		public static List<Vector3> GetStraightPathPoints( List<System.Object> nodePoints )
        {
            if ( nodePoints == null )
                return null;

            List<Vector3> path = new List<Vector3>();
            
            if (nodePoints.Count < 2)
            {
                return null;
            }

            for (int i = 0; i < nodePoints.Count; i++)
            {
					path.Add( GetPositionFromNodeOrVector( nodePoints, i) );	
            }
            return path;
        }

        public static List<Vector3> GetCatmullRomCurvePathPoints( List<System.Object> nodePoints )
        {
            if ( nodePoints == null )
                return null;

			
            List<Vector3> path = new List<Vector3>();
            
            if (nodePoints.Count < 3)
            {
                for( int i = 0; i < nodePoints.Count; i++ )
                {
                    path.Add ( GetPositionFromNodeOrVector( nodePoints, i ) );
                }
                return path;
            }

            Vector3[] catmullRomPoints = new Vector3[nodePoints.Count + 2];
            for( int i = 0; i < nodePoints.Count; i++ )
            {
                catmullRomPoints[i+1] = GetPositionFromNodeOrVector( nodePoints, i );
            }
            int endIndex = catmullRomPoints.Length - 1;

            catmullRomPoints[0] = catmullRomPoints[1] + (catmullRomPoints[1] - catmullRomPoints[2]) + (catmullRomPoints[3] - catmullRomPoints[2]);
            catmullRomPoints[endIndex] = catmullRomPoints[endIndex - 1] + (catmullRomPoints[endIndex - 1] - catmullRomPoints[endIndex - 2])
                                    + (catmullRomPoints[endIndex - 3] - catmullRomPoints[endIndex - 2]);

            path.Add( GetPositionFromNodeOrVector( nodePoints, 0 ) );

            for (int i = 0; i < catmullRomPoints.Length - 3; i++)
            {
                for (float t = 0.05f; t <= 1.0f; t += 0.05f)
                {
                    Vector3 pt = ComputeCatmullRom(catmullRomPoints[i], catmullRomPoints[i + 1], catmullRomPoints[i + 2], catmullRomPoints[i + 3], t);
                    path.Add(pt);
                }
            }

            path.Add( GetPositionFromNodeOrVector( nodePoints, nodePoints.Count - 1 ) );
            return path;
        }

		/* PRIVATES */

		private static PathFollower Create(Transform transform)
		{
			var pathFollower = transform.GetComponent<PathFollower>();
			if (pathFollower == null) pathFollower = transform.gameObject.AddComponent<PathFollower>();
			pathFollower._transform = transform;
			return pathFollower;
		}
		private static PathFollower CreateWithSnapToGround(Transform transform, Vector3 directionOfRayCast, float offsetDistanceFromPoint, float offsetDistanceToFloatFromGround, int maxDistanceForRayCast, int groundLayer)
		{
			var pathFollower = transform.GetComponent<PathFollowerYSnap>();
			if (pathFollower == null) pathFollower = transform.gameObject.AddComponent<PathFollowerYSnap>();

			pathFollower.Init( directionOfRayCast, offsetDistanceFromPoint, offsetDistanceToFloatFromGround, maxDistanceForRayCast, groundLayer);

			pathFollower._transform = transform;
			return pathFollower;
		}
		private static void Stop(Transform transform)
		{
			var pathFollower = transform.GetComponent<PathFollower>();
			if (pathFollower != null) { pathFollower.StopFollowing(); GameObject.Destroy(pathFollower); }
		}
		private static Vector3 ComputeCatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
        {
            float t2 = t * t;
            float t3 = t2 * t;

            Vector3 pt = 0.5f * ((-p0 + 3f * p1 - 3f * p2 + p3) * t3
                        + (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2
                        + (-p0 + p2) * t
                        + 2f * p1);

            return pt;
        }
		private static Vector3 GetClosestPointOnAnyPath ( int nodeID , PathFinder manager, Vector3 pos )
		{
			Node node = manager.graphData.GetNode ( nodeID );
			Vector3 vClosestPoint = node.position;
			float fClosestDist = (pos - node.position).sqrMagnitude;
			bool isOnExtremities = false;

			foreach ( Path p in manager.graphData.paths )
			{
				if ( p.IDOfA == node.autoGeneratedID || p.IDOfB == node.autoGeneratedID ) 
				{
					Vector3 vPos = ComputeClosestPointFromPointToLine(pos, manager.graphData.GetNode( p.IDOfA ).position , manager.graphData.GetNode(p.IDOfB).position, out isOnExtremities );
					float fDist = (vPos - pos).sqrMagnitude;

					if (fDist < fClosestDist)
					{
						fClosestDist = fDist;
						vClosestPoint = vPos;
					}
				}
			}

			//Debug.DrawLine(pos, vClosestPoint, Color.green, 1f);
			return vClosestPoint;
		}

		private static Vector3 ComputeClosestPointFromPointToLine(Vector3 vPt, Vector3 vLinePt0, Vector3 vLinePt1, out bool isOnExtremities )
        {
            float t = -Vector3.Dot(vPt - vLinePt0, vLinePt1 - vLinePt0) / Vector3.Dot(vLinePt0 - vLinePt1, vLinePt1 - vLinePt0);

            Vector3 vClosestPt;

            if (t < 0f)
			{
                vClosestPt = vLinePt0;
				isOnExtremities = true;
			}
            else if (t > 1f)
			{
                vClosestPt = vLinePt1;
				isOnExtremities = true; 
			}
            else
			{
                vClosestPt = vLinePt0 + t * (vLinePt1 - vLinePt0);
				isOnExtremities = false; 
			}

            //Debug.DrawLine(vPt, vClosestPt, Color.red, 1f);
            return vClosestPt;
        }

		static System.Func<List<System.Object> ,int, Vector3> GetPositionFromNodeOrVector = delegate ( List<System.Object> list, int index ) { return (list[index] is Vector3 ? (Vector3)list[index] : ((Node)list[index]).position); };
		
    }

	


}

