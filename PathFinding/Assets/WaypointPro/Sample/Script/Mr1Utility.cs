using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Mr1
{
    public static class PathFinderUtility 
    {
		/* PUBLIC */

		public static void CreatePath (  this WaypointManager manager, Vector3 startPoint, Vector3 endPoint, System.Action<List<Vector3>> OnPathFound, PathLineType pathType,  bool useStraightPathFromStartAndEnd = false )
		{
			int nearestPointFromStart = manager.FindNearestNode ( startPoint );
			int nearestPointFromEnd = -1;
			if ( nearestPointFromStart != -1 )
				nearestPointFromEnd = manager.FindNearestNode ( endPoint );


			if ( nearestPointFromEnd == -1 || nearestPointFromStart == -1 )
			{
				Debug.LogError("ERROR. Could not find the path between " + startPoint.ToString() + " and " + endPoint.ToString() );
				OnPathFound( null );
				return;
			}

			float startTime = Time.realtimeSinceStartup;
            
			manager.FindShortestPathAsynchronous( nearestPointFromStart, nearestPointFromEnd, 
				delegate ( List<Node> wayPoints ) 
                { 
					if ( wayPoints == null || wayPoints.Count == 0 )
						OnPathFound ( null );

					List<Vector3> allWayPoints	= new List<Vector3>();
                    string str = "";
                    if ( wayPoints != null )
                    {
                        foreach ( var a in wayPoints ) 
                        {
							allWayPoints.Add ( a.position );
                            str += "=>" + a.autoGeneratedID.ToString();
                        }
                    }
                    Debug.LogWarning("Path: " + str);
                    Debug.Log("Time Taken:" + (Time.realtimeSinceStartup - startTime));

					List<Vector3> path = null;
					
					if ( useStraightPathFromStartAndEnd )
					{
						path = pathType == PathLineType.Straight ? GetStraightPathPoints(allWayPoints) : GetCatmullRomCurvePathPoints ( allWayPoints );
						path.Insert ( 0, startPoint );
						path.Add ( endPoint );
					}
					else 
					{
						allWayPoints.Insert ( 0, startPoint );
						allWayPoints.Add ( endPoint );

						path = pathType == PathLineType.Straight ? GetStraightPathPoints(allWayPoints) : GetCatmullRomCurvePathPoints ( allWayPoints );
					}

					OnPathFound ( path );
                } );
		}


		public static int FindNearestNode ( this WaypointManager manager, Vector3 point )
		{
			float minDistance = float.MaxValue;
			Node nearestWayPoint = null;

			foreach ( var wayPoint in manager.graphData.nodes )
			{
				if ( Vector3.Distance ( wayPoint.position, point ) < minDistance ) 
				{
					minDistance = Vector3.Distance ( wayPoint.position, point );
					nearestWayPoint = wayPoint;
				}
			}

			return nearestWayPoint != null ? nearestWayPoint.autoGeneratedID : -1;
		}

		//public static PathFollower FollowPath( )

		public static PathFollower FollowPath( Transform transform, List<Vector3> points, float moveSpeed, PathLineType pathType = PathLineType.Straight )
		{
			var pathFollower = Create(transform);
			if (points != null) pathFollower.Follow(points, moveSpeed);
			else Debug.LogError(string.Format("[WaypointManager] couldn't find path"));
			return pathFollower;
		}
		public static PathFollower FollowPathWithGroundSnap( Transform transform, List<Vector3> points, float moveSpeed
																, Vector3 directionOfRayCast, float offsetDistanceFromPoint, float offsetDistanceToFloatFromGround, int maxDistanceForRayCast, int groundLayer
																, PathLineType pathType = PathLineType.Straight )
		{
			var pathFollower = CreateWithSnapToGround(transform, directionOfRayCast, offsetDistanceFromPoint, offsetDistanceToFloatFromGround, maxDistanceForRayCast, groundLayer );
			if (points != null) pathFollower.Follow(points, moveSpeed);
			else Debug.LogError(string.Format("[WaypointManager] couldn't find path"));
			return pathFollower;
		}
		public static void StopFollowing( Transform transform)
		{
			Stop(transform);
		}

		public static List<Vector3> GetStraightPathPoints( List<Vector3> wayPoints )
        {
            if ( wayPoints == null )
                return null;

            List<Vector3> path = new List<Vector3>();
            
            if (wayPoints.Count < 2)
            {
                return null;
            }

            for (int i = 0; i < wayPoints.Count-1; i++)
            {
                for (float t = 0f; t <= 1.0f; t += 0.05f)
                {
                    Vector3 pt = wayPoints[i] * (1f - t) + wayPoints[i + 1] * t;
                    path.Add(pt);
                }
            }

            path.Add(wayPoints[wayPoints.Count - 1]);
            return path;
        }

        public static List<Vector3> GetCatmullRomCurvePathPoints( List<Vector3> wayPoints )
        {
            if ( wayPoints == null )
                return null;

            List<Vector3> path = new List<Vector3>();
            
            if (wayPoints.Count < 3)
            {
                for( int i = 0; i < wayPoints.Count; i++ )
                {
                    path.Add (wayPoints[i] );
                }
                return path;
            }

            Vector3[] catmullRomPoints = new Vector3[wayPoints.Count + 2];
            for( int i = 0; i < wayPoints.Count; i++ )
            {
                catmullRomPoints[i+1] = wayPoints[i];
            }
            int endIndex = catmullRomPoints.Length - 1;

            catmullRomPoints[0] = catmullRomPoints[1] + (catmullRomPoints[1] - catmullRomPoints[2]) + (catmullRomPoints[3] - catmullRomPoints[2]);
            catmullRomPoints[endIndex] = catmullRomPoints[endIndex - 1] + (catmullRomPoints[endIndex - 1] - catmullRomPoints[endIndex - 2])
                                    + (catmullRomPoints[endIndex - 3] - catmullRomPoints[endIndex - 2]);

            path.Add(wayPoints[0]);

            for (int i = 0; i < catmullRomPoints.Length - 3; i++)
            {
                for (float t = 0.05f; t <= 1.0f; t += 0.05f)
                {
                    Vector3 pt = ComputeCatmullRom(catmullRomPoints[i], catmullRomPoints[i + 1], catmullRomPoints[i + 2], catmullRomPoints[i + 3], t);
                    path.Add(pt);
                }
            }

            path.Add(wayPoints[wayPoints.Count - 1]);
            return path;
        }

		/* PRIVATES */

		private static PathFollower Create(Transform transform)
		{
			var pathFollower = transform.GetComponent<PathFollower>();
			if (pathFollower == null) pathFollower = transform.gameObject.AddComponent<PathFollower>();
			pathFollower._transform = transform;
			return pathFollower;
		}
		private static PathFollower CreateWithSnapToGround(Transform transform, Vector3 directionOfRayCast, float offsetDistanceFromPoint, float offsetDistanceToFloatFromGround, int maxDistanceForRayCast, int groundLayer)
		{
			var pathFollower = transform.GetComponent<PathFollowerYSnap>();
			if (pathFollower == null) pathFollower = transform.gameObject.AddComponent<PathFollowerYSnap>();

			pathFollower.Init( directionOfRayCast, offsetDistanceFromPoint, offsetDistanceToFloatFromGround, maxDistanceForRayCast, groundLayer);

			pathFollower._transform = transform;
			return pathFollower;
		}
		private static void Stop(Transform transform)
		{
			var pathFollower = transform.GetComponent<PathFollower>();
			if (pathFollower != null) { pathFollower.StopFollowing(); GameObject.Destroy(pathFollower); }
		}
		private static Vector3 ComputeCatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
        {
            float t2 = t * t;
            float t3 = t2 * t;

            Vector3 pt = 0.5f * ((-p0 + 3f * p1 - 3f * p2 + p3) * t3
                        + (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2
                        + (-p0 + p2) * t
                        + 2f * p1);

            return pt;
        }

    }

}

