using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.Collections.Generic;

using Mr1;

[CustomEditor(typeof(WaypointManager))]
public class WaypointManagerEditor : Editor 
{
    enum SceneMode
    {
        Add,
        Edit,
    }

    SceneMode sceneMode;
    WaypointManager script;

    #region Menu Method

    [MenuItem("GameObject/Create Waypoint Manager")]
    public static void CreateWaypointManager()
    {
        if (GameObject.FindObjectOfType<WaypointManager>() == null)
        {
            var managerGo = new GameObject("WaypointManager");
            var manager = managerGo.AddComponent<WaypointManager>();
            var boxCollider = managerGo.AddComponent<BoxCollider>();
            boxCollider.size = new Vector3(100f, 100f, 1f);
            boxCollider.isTrigger = true;
        }
        else
            Debug.LogError("Waypoint Manager already exists!");
    }

    #endregion

    void OnEnable()
    {
        sceneMode = SceneMode.Edit;
        script = target as WaypointManager;
        if (script.pathList == null) script.pathList = new List<PathData>();
        for (int i = 0; i < script.pathList.Count; i++)
        {
            if (script.pathList[i] == null) script.pathList.RemoveAt(i);
        }

        script.selected = null;
        foreach(var path in script.pathList)
        {
            if (path != null)
            {
                String strAssetPath = AssetDatabase.GetAssetPath(path);
                int startIndex = strAssetPath.LastIndexOf("/") + 1;
                int length = strAssetPath.LastIndexOf(".") - startIndex;
                path.pathName = strAssetPath.Substring(startIndex, length);
            }
        }
    }

    void OnDisable()
    {
        AssetDatabase.SaveAssets();
        if (script != null)
        {
            EditorUtility.SetDirty(script);
            foreach (var path in script.pathList)
            {
                if (path != null) EditorUtility.SetDirty(path);
            }
        }
    }

    public override void OnInspectorGUI()
    {
        //base.DrawDefaultInspector();

        ShowButtons();

        CustomGUI.DrawSeparator(Color.gray);

        ShowPointsAndPathInInspector();
        CheckGUIChanged();
    }

    #region OnInspectorGUI's Display Method

    void ShowButtons()
    {
        GUILayout.BeginHorizontal();

        if (GUILayout.Button("New Path"))
        {
            PathData newPath = CreatePathAsset();
            if (newPath != null) script.pathList.Add(newPath);
        }
        if (GUILayout.Button("Load Path"))
        {
            PathData loadedPath = LoadPathAsset();
            if (loadedPath != null)
            {
                if (!script.pathList.Contains(loadedPath))
                    script.pathList.Add(loadedPath);
            }
        }

        GUILayout.EndHorizontal();
    }

    void ShowPointsAndPathInInspector()
    {
        for (int i = 0; i < script.pathList.Count; i++)
        {
            Action delAction = () => { script.pathList.RemoveAt(i); };
            if (script.pathList[i] == null || string.IsNullOrEmpty(script.pathList[i].pathName)) continue;
            if (CustomGUI.HeaderButton(script.pathList[i].pathName, null, delAction))
            {
                script.selected = script.pathList[i];
                script.selected.pointSize = EditorGUILayout.Slider("Point Size", script.selected.pointSize, 0.1f, 3f);
                script.selected.lineColor = EditorGUILayout.ColorField("Path Color", script.selected.lineColor);
                script.selected.lineType = (PathLineType)EditorGUILayout.EnumPopup("Path Type", script.selected.lineType);

                List<WayPoint> wayPointList = script.selected.points;


                for (int j = 0; j < wayPointList.Count; j++)
                {
                    GUILayout.BeginHorizontal();
                    {
                        wayPointList[j].position = EditorGUILayout.Vector3Field("Point " + wayPointList[j].autoGeneratedID, wayPointList[j].position);
                        if (GUILayout.Button("+", GUILayout.Width(25f)))
                            AddWaypoint(wayPointList[j].position + Vector3.right + Vector3.up, j + 1);
                        if (GUILayout.Button("-", GUILayout.Width(25f)))
                            DeleteWaypoint(j);
                    }
                    GUILayout.EndHorizontal();
                }

                List<WayPath> wayPaths = script.selected.paths;

                for (int j = 0; j < wayPaths.Count; j++)
                {
                    GUILayout.BeginHorizontal();
                    {
                        EditorGUILayout.LabelField ("Path " + wayPaths[j].autoGeneratedID);
                        
                        wayPaths[j].IDOfA = EditorGUILayout.IntField (wayPaths[j].IDOfA );
                        wayPaths[j].IDOfB = EditorGUILayout.IntField (wayPaths[j].IDOfB );
                        wayPaths[j].cost = EditorGUILayout.IntField (wayPaths[j].cost );

                        if (GUILayout.Button("+", GUILayout.Width(25f)))
                            AddWayPath(j + 1);
                        if (GUILayout.Button("-", GUILayout.Width(25f)))
                            DeleteWayPath(j);
                    }
                    GUILayout.EndHorizontal();
                }
            }
        }
    }

    #endregion

    #region Path Asset Method

    PathData CreatePathAsset()
    {
        string strAssetPath = EditorUtility.SaveFilePanelInProject("New Path", "NewPath", "asset", "");
        
        if (string.IsNullOrEmpty(strAssetPath))
            return null;

        strAssetPath = AssetDatabase.GenerateUniqueAssetPath(strAssetPath);

        int startIndex = strAssetPath.LastIndexOf("/") + 1;
        int length = strAssetPath.LastIndexOf(".") - startIndex;
        string strAssetName = strAssetPath.Substring(startIndex, length);

        PathData newPath = ScriptableObject.CreateInstance<PathData>();
        newPath.pathName = strAssetName;

        AssetDatabase.CreateAsset(newPath, strAssetPath);
        AssetDatabase.SaveAssets();

        return newPath;
    }

    PathData LoadPathAsset()
    {
        string strAssetPath = EditorUtility.OpenFilePanel("Load Path", "Assets/", "asset");
        strAssetPath = strAssetPath.Substring(strAssetPath.IndexOf("Assets/"));

        if (string.IsNullOrEmpty(strAssetPath))
            return null;
        
        PathData loadedPath = (PathData)AssetDatabase.LoadAssetAtPath(strAssetPath, typeof(PathData));

        int startIndex = strAssetPath.LastIndexOf("/") + 1;
        int length = strAssetPath.LastIndexOf(".") - startIndex;
        string strAssetName = strAssetPath.Substring(startIndex, length);

        loadedPath.pathName = strAssetName;

        return loadedPath;
    }
    
    void SavePathAsset()
    {
        AssetDatabase.SaveAssets();
        foreach (var path in script.pathList)
            EditorUtility.SetDirty(path);
    }

    #endregion

    void OnSceneGUI()
    {
        int controlID = GUIUtility.GetControlID(FocusType.Passive);
        HandleUtility.AddDefaultControl(controlID);

        if (script.selected != null)
        {
            DrawWindow();

            if (sceneMode == SceneMode.Add)
            {
                UpdateMouseInput();
                DrawWaypointInAddMode();
            }
            else if (sceneMode == SceneMode.Edit)
            {
                DrawHandlePointInEditMode();
            }

            DrawPathLine();
        }

        CheckGUIChanged();
    }

    #region Input Method

    void UpdateMouseInput()
    {
        Event e = Event.current;
        if (e.type == EventType.MouseDown)
        {
            if (e.button == 0)
                OnMouseClick(e.mousePosition);
        }
    }

    void OnMouseClick(Vector2 mousePos)
    {
        LayerMask backgroundLayerMask = 1 << script.gameObject.layer;

        Ray ray = HandleUtility.GUIPointToWorldRay(mousePos);
        RaycastHit hit;
        if (Physics.Raycast(ray, out hit, 1000f, backgroundLayerMask))
        {
            Vector3 hitPos = hit.point;
            AddWaypoint(hitPos);
        }
    }

    #endregion

    #region OnSceneGUI's Draw Method

    void DrawWindow()
    {
        GUILayout.Window(1, new Rect(0f, 25f, 70f, 80f), DoWaypointWindow, script.selected.pathName);
    }

    void DoWaypointWindow(int windowID)
    {
        EditorGUILayout.BeginVertical();

        sceneMode = (SceneMode)GUILayout.SelectionGrid((int)sceneMode, System.Enum.GetNames(typeof(SceneMode)), 1);

        if (GUILayout.Button("Add - Immediate"))
            AddImmediateWaypoint();

        if (GUILayout.Button("Del"))
            DeleteWaypoint();

        if (GUILayout.Button("Clear"))
        {
            ClearWaypoint();
            ClearWayPath();
        }

		if (GUILayout.Button("Refresh"))
			AutoGenerateStuff();

        if (GUILayout.Button("Do something "))
			DoSomething();

        GUI.color = Color.green;
        script.selected.lineType = (PathLineType)EditorGUILayout.EnumPopup(script.selected.lineType);
        GUI.color = Color.white;

        EditorGUILayout.EndVertical();

        if (GUI.changed)
        {
            SetLinePoints();
        }

        //GUI.DragWindow();
    }

    void DrawWaypointInAddMode()
    {
        Handles.color = Color.green;
        foreach (var point in script.selected.points)
        {
            Handles.SphereCap(0, point.position, Quaternion.identity, script.selected.pointSize);
        }
        Handles.color = Color.white;

        // GUI display about the way points in the scene view
        DrawGUIDisplayForPoints();

        Handles.color = Color.white;
    }

    void DrawPathLine()
    {
        List<WayPath> paths = script.selected.paths;
        List<WayPoint> linePoints = script.selected.points;
        Vector3 currPoint;
        Vector2 guiPosition;

        if (paths == null || linePoints == null ) return;

        Handles.color = script.selected.lineColor;
        WayPoint a,b;

        

        for (int i = 0; i < paths.Count; i++)
        {
            a = b = null;

            if ( script.selected.pointsSorted.ContainsKey(paths[i].IDOfA))
                a = script.selected.pointsSorted[paths[i].IDOfA];

            if ( script.selected.pointsSorted.ContainsKey(paths[i].IDOfB))
                b = script.selected.pointsSorted[paths[i].IDOfB];

            if ( a != null && b != null && a != b ) 
            {
                Handles.DrawLine(a.position, b.position);

                Handles.BeginGUI();
                {
                    currPoint = (a.position + b.position) / 2;

                    guiPosition = HandleUtility.WorldToGUIPoint ( currPoint );
                    GUI.Box( new Rect (guiPosition.x - 10, guiPosition.y - 30, 40, 20 ), paths[i].autoGeneratedID.ToString() + ":" + paths[i].cost.ToString() );
                }
                Handles.EndGUI();
                
            }
        }



        Handles.color = Color.white;
    }

    public void DrawGUIDisplayForPoints()
    {
        WayPoint currPoint;
        Vector2 guiPosition;

        Handles.BeginGUI();
        for ( int i = 0; i < script.selected.points.Count; i++ ) 
        {
            currPoint = script.selected.points[i];

            guiPosition = HandleUtility.WorldToGUIPoint ( currPoint.position );
            GUI.Box( new Rect (guiPosition.x - 10, guiPosition.y - 30, 20, 20 ), currPoint.autoGeneratedID.ToString());
        }
        Handles.EndGUI();
    }

    void DrawHandlePointInEditMode()
    {
        List<WayPoint> wayPoints = script.selected.points;

        for (int i = 0; i < wayPoints.Count; i++)
        {
            Handles.color = Color.magenta;
            wayPoints[i].position = Handles.FreeMoveHandle(wayPoints[i].position, Quaternion.identity, script.selected.pointSize, Vector3.zero, Handles.SphereCap);

            // if (script.selected.lineType == PathLineType.BezierCurve)
            // {
            //     Vector3 firstControlPoint = wayPoints[i] + script.selected.firstHandles[i];
            //     Vector3 secondControlPoint = wayPoints[i] + script.selected.secondHandles[i];

            //     Handles.color = Color.gray;
            //     if (i != 0)
            //     {
            //         Vector3 movedPoint = Handles.FreeMoveHandle(firstControlPoint, Quaternion.identity, script.selected.pointSize, Vector3.zero, Handles.SphereCap);
            //         if (firstControlPoint != movedPoint)
            //         {
            //             firstControlPoint = movedPoint - wayPoints[i];

            //             Quaternion qRot = Quaternion.FromToRotation(script.selected.firstHandles[i], firstControlPoint);
            //             script.selected.secondHandles[i] = qRot * script.selected.secondHandles[i];
            //             script.selected.firstHandles[i] = firstControlPoint;
            //         }
            //         Handles.DrawLine(wayPoints[i], firstControlPoint);
            //     }
            //     if (i != wayPoints.Count - 1)
            //     {
            //         Vector3 movedPoint = Handles.FreeMoveHandle(secondControlPoint, Quaternion.identity, script.selected.pointSize, Vector3.zero, Handles.SphereCap);
            //         if (secondControlPoint != movedPoint)
            //         {
            //             secondControlPoint = movedPoint - wayPoints[i];

            //             Quaternion qRot = Quaternion.FromToRotation(script.selected.secondHandles[i], secondControlPoint);
            //             script.selected.firstHandles[i] = qRot * script.selected.firstHandles[i];
            //             script.selected.secondHandles[i] = secondControlPoint;
            //         }
            //         Handles.DrawLine(wayPoints[i], secondControlPoint);
            //     }
            //     Handles.color = Color.white;
            // }
        }

        Handles.color = Color.white;

        // GUI display about the way points in the scene view
        Handles.BeginGUI();
        DrawGUIDisplayForPoints();

        Handles.color = Color.white;
    }

    #endregion

    #region Line Points Setting Method

    void AutoGenerateStuff ( )
    {
        if ( script.selected == null || script.selected.points == null )
            return;

        //Generate IDs for way points
        {
            int maxID = 0;
            
            for ( int i = 0; i < script.selected.points.Count; i++  )
            {
                if ( script.selected.points[i].autoGeneratedID > maxID ) 
                    maxID = script.selected.points[i].autoGeneratedID;
            }

            maxID = maxID + 1;

            for ( int i = 0; i < script.selected.points.Count; i++  )
            {
                if ( script.selected.points[i].autoGeneratedID <= 0  ) 
                    script.selected.points[i].autoGeneratedID = maxID++;
            }
        }

        // generate IDs for way paths.
        {
            int maxID = 0;
            for ( int i = 0; i < script.selected.paths.Count; i++  )
            {
                if ( script.selected.paths[i].autoGeneratedID > maxID ) 
                    maxID = script.selected.paths[i].autoGeneratedID;
            }

            maxID = maxID + 1;

            for ( int i = 0; i < script.selected.paths.Count; i++  )
            {
                if ( script.selected.paths[i].autoGeneratedID <= 0  ) 
                    script.selected.paths[i].autoGeneratedID = maxID++;
            }
        }

        // refreshing dictionaries
        {
            script.selected.pathsSorted.Clear();
            script.selected.pointsSorted.Clear();

            for ( int i = 0; i < script.selected.points.Count; i++  )
            {
                script.selected.pointsSorted[ script.selected.points[i].autoGeneratedID ] = script.selected.points[i] ;
            }

            for ( int i = 0; i < script.selected.paths.Count; i++  )
            {
                script.selected.pathsSorted[ script.selected.paths[i].autoGeneratedID ] = script.selected.paths[i] ;
            }
        }
    }
    void SetLinePoints()
    {
        if (script.selected == null) return;

        switch (script.selected.lineType)
        {
            case PathLineType.Straight: SetStraightLine(); break;
            case PathLineType.CatmullRomCurve: SetCatmullRomCurveLine(); break;
            case PathLineType.BezierCurve: SetBezierCurveLine(); break;
        }

        SceneView.RepaintAll();
    }

    void SetStraightLine()
    {
        // List<Vector3> wayPoints = script.selected.points;
        // if (wayPoints.Count < 2)
        //     return;

        // for (int i = 0; i < wayPoints.Count-1; i++)
        // {
        //     for (float t = 0f; t <= 1.0f; t += 0.05f)
        //     {
        //         Vector3 pt = wayPoints[i] * (1f - t) + wayPoints[i + 1] * t;
        //         script.selected.linePoints.Add(pt);
        //     }
        // }

        // script.selected.linePoints.Add(wayPoints[wayPoints.Count - 1]);
    }

    void SetCatmullRomCurveLine()
    {
        // List<Vector3> wayPoints = script.selected.points;

        // if (wayPoints.Count < 3)
        //     return;

        // Vector3[] catmullRomPoints = new Vector3[wayPoints.Count + 2];
        // wayPoints.CopyTo(catmullRomPoints, 1);

        // int endIndex = catmullRomPoints.Length - 1;

        // catmullRomPoints[0] = catmullRomPoints[1] + (catmullRomPoints[1] - catmullRomPoints[2]) + (catmullRomPoints[3] - catmullRomPoints[2]);
        // catmullRomPoints[endIndex] = catmullRomPoints[endIndex - 1] + (catmullRomPoints[endIndex - 1] - catmullRomPoints[endIndex - 2])
        //                         + (catmullRomPoints[endIndex - 3] - catmullRomPoints[endIndex - 2]);

        // script.selected.linePoints.Add(wayPoints[0]);

        // for (int i = 0; i < catmullRomPoints.Length - 3; i++)
        // {
        //     for (float t = 0.05f; t <= 1.0f; t += 0.05f)
        //     {
        //         Vector3 pt = ComputeCatmullRom(catmullRomPoints[i], catmullRomPoints[i + 1], catmullRomPoints[i + 2], catmullRomPoints[i + 3], t);
        //         script.selected.linePoints.Add(pt);
        //     }
        // }

        // script.selected.linePoints.Add(wayPoints[wayPoints.Count - 1]);
    }

    Vector3 ComputeCatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
    {
        float t2 = t * t;
        float t3 = t2 * t;

        Vector3 pt = 0.5f * ((-p0 + 3f * p1 - 3f * p2 + p3) * t3
                    + (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2
                    + (-p0 + p2) * t
                    + 2f * p1);

        return pt;
    }

    void SetBezierCurveLine()
    {
        // List<Vector3> wayPoints = script.selected.points;
        // List<Vector3> firstControls = script.selected.firstHandles;
        // List<Vector3> secondControls = script.selected.secondHandles;

        // if (wayPoints.Count < 2)
        //     return;

        // script.selected.linePoints.Add(wayPoints[0]);

        // for (int i = 0; i < wayPoints.Count - 1; i++)
        // {
        //     Vector3 waypoint1 = wayPoints[i];
        //     Vector3 waypoint2 = wayPoints[i + 1];
        //     Vector3 controlPoint1 = wayPoints[i] + secondControls[i];
        //     Vector3 controlPoint2 = wayPoints[i + 1] + firstControls[i + 1];

        //     for (float t = 0.05f; t <= 1.0f; t += 0.05f)
        //     {
        //         Vector3 pt = ComputeBezier(waypoint1, controlPoint1, controlPoint2, waypoint2, t);

        //         script.selected.linePoints.Add(pt);
        //     }
        // }

        // script.selected.linePoints.Add(wayPoints[wayPoints.Count-1]);
    }

    Vector3 ComputeBezier(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
    {
        float t2 = t * t;
        float t3 = t * t * t;
        float _t2 = (1 - t) * (1 - t);
        float _t3 = (1 - t) * (1 - t) * (1 - t);

        return p0 * _t3 + 3f * p1 * t * _t2 + 3 * p2 * t2 * (1 - t) + p3 * t3;
    }

    #endregion

    #region Waypoint Method

    void AddWaypoint(Vector3 position, int addIndex = -1)
    {
        if (addIndex == -1)
            script.selected.points.Add( new WayPoint( position ));
        else
            script.selected.points.Insert(addIndex, new WayPoint( position ));

        // script.selected.firstHandles.Add(Vector3.left);
        // script.selected.secondHandles.Add(Vector3.right);
        SetLinePoints();
        AutoGenerateStuff();
    }
	
	void AddImmediateWaypoint()
    {
        Vector3 position = Vector3.zero;;

        const float distanceOffset = 5;

        if (script.selected.points == null || script.selected.points.Count == 0)
        {
            position = Vector3.zero;
        }
        else if ( script.selected.points.Count == 1 )
        {
            position += Vector3.right * distanceOffset;
        }
        else 
        {
            position = script.selected.points[script.selected.points.Count - 1].position;
            Vector3 dir = ( script.selected.points[script.selected.points.Count - 1].position - script.selected.points[script.selected.points.Count - 2].position ).normalized;
            position += dir * distanceOffset;
        }

        script.selected.points.Add( new WayPoint( position ));

        // script.selected.firstHandles.Add(Vector3.left);
        // script.selected.secondHandles.Add(Vector3.right);
        SetLinePoints();
        AutoGenerateStuff();
    }

    void DeleteWaypoint(int removeIndex = -1)
    {
        List<WayPoint> wayPointList = script.selected.points;
        if (wayPointList == null || wayPointList.Count == 0)
            return;

        if (removeIndex == -1) removeIndex = wayPointList.Count - 1;
        wayPointList.RemoveAt(removeIndex);
        // script.selected.firstHandles.RemoveAt(removeIndex);
        // script.selected.secondHandles.RemoveAt(removeIndex);
        SetLinePoints();
        AutoGenerateStuff();
    }

    void ClearWaypoint()
    {
        script.selected.points.Clear();
        // script.selected.firstHandles.Clear();
        // script.selected.secondHandles.Clear();
        SetLinePoints();
    }

    void AddWayPath( int addIndex = -1)
    {
        if (addIndex == -1)
            script.selected.paths.Add( new WayPath( -1, -1 ));
        else
            script.selected.paths.Insert(addIndex, new WayPath( -1, -1 ));

        // script.selected.firstHandles.Add(Vector3.left);
        // script.selected.secondHandles.Add(Vector3.right);
        AutoGenerateStuff();
    }

    void DeleteWayPath(int removeIndex = -1)
    {
        List<WayPath> wayPathList = script.selected.paths;
        if (wayPathList == null || wayPathList.Count == 0)
            return;

        if (removeIndex == -1) removeIndex = wayPathList.Count - 1;
        wayPathList.RemoveAt(removeIndex);
        // script.selected.firstHandles.RemoveAt(removeIndex);
        // script.selected.secondHandles.RemoveAt(removeIndex);
        AutoGenerateStuff();
    }

    void ClearWayPath()
    {
        script.selected.paths.Clear();
        // script.selected.firstHandles.Clear();
        // script.selected.secondHandles.Clear();
    }


    #endregion

    void CheckGUIChanged()
    {
        if (GUI.changed)
        {
            SetLinePoints();
            AssetDatabase.SaveAssets();
            SceneView.RepaintAll();
        }
    }

    void DoSomething()
    {
        int startPointID = 1; 
        int endPointID = 2;
		bool found = false;

        AutoGenerateStuff();

        WayPoint startPoint = script.selected.pointsSorted[startPointID];
        WayPoint endPoint = script.selected.pointsSorted[endPointID];

        foreach( var point in script.selected.points )
        {
            point.HeuristicDistance = -1;
            point.previousWayPoint = null;
        }

        List<WayPoint> completedPoints = new List<WayPoint>();
        List<WayPoint> NextPoints = new List<WayPoint>();

        startPoint.pathDistance = 0;
		startPoint.HeuristicDistance = Vector3.Distance ( startPoint.position, endPoint.position );
        NextPoints.Add( startPoint );

        while ( true )
        {
            WayPoint leastCostPoint = null; 
            
            float minCost = 99999;
            foreach ( var point in NextPoints )
            {
                if ( point.HeuristicDistance <= 0 )
                    point.HeuristicDistance = Vector3.Distance ( point.position, endPoint.position );

                if ( minCost > point.combinedHeuristic )
                {
                    leastCostPoint = point;
                    minCost = point.combinedHeuristic;
                }
            }

			if ( leastCostPoint == null ) 
				break;
			
            if ( leastCostPoint == endPoint )
            {
				found = true;
				WayPoint prevPoint = leastCostPoint;
				string str = "";
				while ( prevPoint != null ) 
				{
					str += "=>" + prevPoint.autoGeneratedID.ToString();
					prevPoint = prevPoint.previousWayPoint;
				}

				Debug.LogWarning("Path:" + str);
                break;
            }

            foreach ( var path in script.selected.paths )
            {
                if ( path.IDOfA == leastCostPoint.autoGeneratedID 
                || path.IDOfB == leastCostPoint.autoGeneratedID )
                {
                    WayPoint otherPoint = path.IDOfA == leastCostPoint.autoGeneratedID ? 
                                            script.selected.pointsSorted[path.IDOfB] : script.selected.pointsSorted[path.IDOfA];

                    if ( otherPoint.HeuristicDistance <= 0 )
                        otherPoint.HeuristicDistance = Vector3.Distance ( otherPoint.position, endPoint.position );

                    if ( completedPoints.Contains ( otherPoint) )
                        continue;

                    if ( NextPoints.Contains( otherPoint ))
                    {
                        if ( otherPoint.pathDistance > 
                            ( leastCostPoint.pathDistance + path.cost ) )
                        {
                            otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                            otherPoint.previousWayPoint = leastCostPoint;
                        }
                    }
                    else
                    {
                        otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                        otherPoint.previousWayPoint = leastCostPoint;
                        NextPoints.Add ( otherPoint );
                    }
                }
            }

			NextPoints.Remove ( leastCostPoint );
			completedPoints.Add ( leastCostPoint );
        }       

		if ( !found ) 
		{
			Debug.LogError("No path found");
		}
    }
}
