using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor.SceneManagement;

using Mr1;

[CustomEditor(typeof(WaypointManager))]
public class WaypointManagerEditor : Editor 
{
    enum SceneMode
    {
        AddPoint,
        EditPoint,
        ConnectPath,
        None
    }

    SceneMode sceneMode;
    WaypointManager script;
    const string WayPointTextcolor = "#ff00ffff";
    const string ConnectionTextcolor = "#00ffffff";
    const string CostTextcolor = "#0000ffff";


#region Instantiation and Asset management 

    [MenuItem("GameObject/Create Waypoint Manager")]
    public static void CreateWaypointManager()
    {
        if (GameObject.FindObjectOfType<WaypointManager>() == null)
        {
            var managerGo = new GameObject("WaypointManager");
            var manager = managerGo.AddComponent<WaypointManager>();
            var boxCollider = managerGo.AddComponent<BoxCollider>();
            boxCollider.size = new Vector3(100f, 100f, 1f);
            boxCollider.isTrigger = true;
        }
        else
            Debug.LogError("Waypoint Manager already exists!");
    }


    private void MarkThisDirty ()
    {
        if ( PrefabUtility.GetPrefabParent( script.gameObject ) != null ) 
        {
            Debug.Log("Prefab found for WayPointManager!");
            EditorUtility.SetDirty(script);
        }
        else 
        {
            Debug.LogWarning("No Prefab found for WayPointManager!");   // This is not an issue , but make sure u save the scene when u modify WayPointManager data
            EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
        }
    }

    void OnEnable()
    {
        sceneMode = SceneMode.EditPoint;
        script = target as WaypointManager;
        script.pathData.Refresh();
    }


#endregion


    
#region OnInspectorGUI's Display Method

    public override void OnInspectorGUI()
    {
        showDefaultInspector = EditorGUILayout.Toggle ( "Show Default inspector", showDefaultInspector );
        if ( showDefaultInspector )
        {
            DrawDefaultInspector();
        }
        else 
        {
            CustomGUI.DrawSeparator(Color.gray);
            ShowPointsAndPathInInspector();
        }
    }

    void ShowPointsAndPathInInspector()
    {
        script.pathData.pointSize = EditorGUILayout.Slider("Point Size", script.pathData.pointSize, 0.1f, 3f);
        script.pathData.lineColor = EditorGUILayout.ColorField("Path Color", script.pathData.lineColor);
        script.pathData.lineType = (PathLineType)EditorGUILayout.EnumPopup("Path Type", script.pathData.lineType);


        GUILayout.Label ( "<size=15><b>Way Points</b></size>", Utility.GetStyleWithRichText());

        
        showPointIDsInTheScene = EditorGUILayout.Toggle ( "Show Point IDs in scene", showPointIDsInTheScene );

        List<WayPoint> wayPointList = script.pathData.points;
        for (int j = 0; j < wayPointList.Count; j++)
        {
            GUILayout.BeginHorizontal();
            {
                EditorGUILayout.LabelField ("\t" + "Point <Color=" + WayPointTextcolor + ">" + wayPointList[j].autoGeneratedID + "</Color>", Utility.GetStyleWithRichText(), GUILayout.Width ( 120f ) );

                wayPointList[j].position = EditorGUILayout.Vector3Field("", wayPointList[j].position);
                if (GUILayout.Button("+", GUILayout.Width(25f)))
                    AddWaypoint(wayPointList[j].position + Vector3.right + Vector3.up, j + 1);
                if (GUILayout.Button("-", GUILayout.Width(25f)))
                    DeleteWaypoint(j);
            }
            GUILayout.EndHorizontal();
        }


        GUILayout.Label ( "<size=15><b>Way Paths</b></size>", Utility.GetStyleWithRichText());
        showPathIDsInTheScene = EditorGUILayout.Toggle ( "Show Path IDs in scene", showPathIDsInTheScene );
        showCostsInTheScene = EditorGUILayout.Toggle ( "Show Path Costs in scene", showCostsInTheScene );

        List<WayPath> wayPaths = script.pathData.paths;
        for (int j = 0; j < wayPaths.Count; j++)
        {
            GUILayout.BeginHorizontal();
            {
                EditorGUILayout.LabelField ("\t" + "Path <Color=" + ConnectionTextcolor + ">" + wayPaths[j].autoGeneratedID + "</Color>", Utility.GetStyleWithRichText(), GUILayout.Width ( 120f ) );

                EditorGUILayout.LabelField ("From", EditorStyles.miniLabel, GUILayout.Width(30f) ); wayPaths[j].IDOfA = EditorGUILayout.IntField (wayPaths[j].IDOfA, GUILayout.Width(50f)  );
                EditorGUILayout.LabelField ("To", EditorStyles.miniLabel, GUILayout.Width(25f) ); wayPaths[j].IDOfB = EditorGUILayout.IntField (wayPaths[j].IDOfB, GUILayout.Width(50f)  );
                EditorGUILayout.LabelField ( "<Color=" + CostTextcolor + ">" + "Cost" + "</Color>", Utility.GetStyleWithRichText(EditorStyles.miniLabel), GUILayout.Width(30f) ); wayPaths[j].cost = EditorGUILayout.IntField (wayPaths[j].cost, GUILayout.Width(50f)  );

                EditorGUILayout.LabelField ("One Way", EditorStyles.miniLabel, GUILayout.Width(50f) ); wayPaths[j].isOneWay = EditorGUILayout.Toggle (wayPaths[j].isOneWay );

                if (GUILayout.Button("+", GUILayout.Width(25f)))
                    AddWayPath(j + 1);
                if (GUILayout.Button("-", GUILayout.Width(25f)))
                    DeleteWayPath(j);
            }
            GUILayout.EndHorizontal();
        }

        if ( GUI.changed )
            MarkThisDirty();
    }

#endregion

#region Scene Rendering Display Method

    void OnSceneGUI()
    {
        int controlID = GUIUtility.GetControlID(FocusType.Passive);
        HandleUtility.AddDefaultControl(controlID);

        {
            DrawGUIWindowOnScene();
            UpdateMouseInput();

            if (sceneMode == SceneMode.AddPoint)
            {
                DrawWaypoints( Color.green );
            }
            else if (sceneMode == SceneMode.EditPoint)
            {
                DrawWaypoints ( Color.magenta, true );
            }
            else if ( sceneMode == SceneMode.ConnectPath )
            {
				DrawWaypoints( Color.green, false, script.pathData.GetWayPoint( selectedPointForConnectPointsMode ), Color.red );
            }
            else 
                DrawWaypoints ( Color.gray );

            DrawPathLine();
        }

        CheckGUIChanged();
    }

    void CheckGUIChanged()
    {
        if (GUI.changed)
        {
            //SetLinePoints();
            //AssetDatabase.SaveAssets();
            SceneView.RepaintAll();
        }
    }
    void DrawGUIWindowOnScene()
    {
        GUILayout.Window(1, new Rect(0f, 25f, 70f, 80f), 
                                                        delegate ( int windowID )
                                                        {
                                                            EditorGUILayout.BeginHorizontal();

                                                            sceneMode = (SceneMode)GUILayout.SelectionGrid((int)sceneMode, System.Enum.GetNames(typeof(SceneMode)), 1);

                                                            GUI.color = Color.white;

                                                            EditorGUILayout.EndHorizontal();
                                                        }
            , "Mode");
        GUILayout.Window(2, new Rect(0, 155f, 70f, 80f), 
                                                        delegate(int windowID)
                                                        {
                                                            EditorGUILayout.BeginVertical();

                                                            //sceneMode = (SceneMode)GUILayout.SelectionGrid((int)sceneMode, System.Enum.GetNames(typeof(SceneMode)), 1);

                                                            // if (GUILayout.Button("Add - Immediate"))
                                                            //     AddImmediateWaypoint();

                                                            if (GUILayout.Button("Delete Point"))
                                                                DeleteWaypoint();

                                                            if (GUILayout.Button("Delete Path"))
                                                                DeleteWayPath();

                                                            if (GUILayout.Button("Clear"))
                                                            {
                                                                ClearWaypoint();
                                                                ClearWayPath();
                                                            }

                                                            if (GUILayout.Button("Refresh Data"))
                                                            {
                                                                script.pathData.Refresh();   
                                                            }
                                                            GUI.color = Color.white;

                                                            EditorGUILayout.EndVertical();
                                                        }
            , "");
    }
    

    void DrawWaypoints( Color color, bool canMove = false, WayPoint selectedPoint = null, Color colorForSelected = default(Color) )
    {
        Handles.color = color;
        foreach (var point in script.pathData.points)
        {
            if ( selectedPoint != null && point == selectedPoint )
                Handles.color = colorForSelected;
            else 
                Handles.color = color;

            if ( canMove ) 
                point.position = Handles.FreeMoveHandle(point.position, Quaternion.identity, script.pathData.pointSize, Vector3.zero, Handles.SphereCap);
            else
                Handles.SphereCap(0, point.position, Quaternion.identity, script.pathData.pointSize);
        }
        Handles.color = Color.white;

        // GUI display about the way points in the scene view
        DrawGUIDisplayForPoints();

        Handles.color = Color.white;
    }



    void DrawPathLine()
    {
        List<WayPath> paths = script.pathData.paths;
        List<WayPoint> linePoints = script.pathData.points;
        Vector3 currPoint;
        Vector2 guiPosition;

        if (paths == null || linePoints == null ) return;

        Handles.color = script.pathData.lineColor;
        WayPoint a,b;

        

        for (int i = 0; i < paths.Count; i++)
        {
            a = b = null;

            if ( script.pathData.pointsSorted.ContainsKey(paths[i].IDOfA))
                a = script.pathData.pointsSorted[paths[i].IDOfA];

            if ( script.pathData.pointsSorted.ContainsKey(paths[i].IDOfB))
                b = script.pathData.pointsSorted[paths[i].IDOfB];

            if ( a != null && b != null && a != b ) 
            {
                Handles.DrawLine(a.position, b.position);

                Handles.BeginGUI();
                {
                    currPoint = (a.position + b.position) / 2;

                    guiPosition = HandleUtility.WorldToGUIPoint ( currPoint );

                    string str = "";

                    if ( showPathIDsInTheScene )
                        str += "<Color=" + ConnectionTextcolor + ">" + paths[i].autoGeneratedID.ToString() + "</Color>";
                    if ( showCostsInTheScene )
                    {
                        if ( !string.IsNullOrEmpty( str ) )
                            str += "<Color=" + "#ffffff" + ">" + "  Cost: " + "</Color>";

                        str += "<Color=" + CostTextcolor + ">" + paths[i].cost.ToString()  + "</Color>";
                    }

                    if ( !string.IsNullOrEmpty( str ) )
                        GUI.Label (new Rect (guiPosition.x - 10, guiPosition.y - 30, 40, 20 ),  str , Utility.GetStyleWithRichText() );
                }
                Handles.EndGUI();
                
            }
        }



        Handles.color = Color.white;
    }

    public void DrawGUIDisplayForPoints()
    {
        if ( !showPointIDsInTheScene )
            return;

        WayPoint currPoint;
        Vector2 guiPosition;

        Handles.BeginGUI();
        for ( int i = 0; i < script.pathData.points.Count; i++ ) 
        {
            currPoint = script.pathData.points[i];

            guiPosition = HandleUtility.WorldToGUIPoint ( currPoint.position );
            
            GUI.Label( new Rect (guiPosition.x - 10, guiPosition.y - 30, 20, 20 ), "<Color=" + WayPointTextcolor + ">" + currPoint.autoGeneratedID.ToString() + "</Color>", Utility.GetStyleWithRichText());
        }
        Handles.EndGUI();
    }

#endregion

#region Input Method

    void UpdateMouseInput()
    {
        Event e = Event.current;
        if (e.type == EventType.MouseDown)
        {
            if (e.button == 0)
                OnMouseClick(e.mousePosition);
        }
        else if ( e.type == EventType.MouseUp )
        {
            MarkThisDirty();
        }
            
    }

    void OnMouseClick(Vector2 mousePos)
    {
        if( sceneMode == SceneMode.AddPoint ) 
        {
            LayerMask backgroundLayerMask = 1 << script.gameObject.layer;

            Ray ray = HandleUtility.GUIPointToWorldRay(mousePos);
            RaycastHit hit;
            if (Physics.Raycast(ray, out hit, 1000f, backgroundLayerMask))
            {
                Vector3 hitPos = hit.point;
                AddWaypoint(hitPos);
            }
        }
        else if ( sceneMode == SceneMode.ConnectPath )
        {
            LayerMask backgroundLayerMask = 1 << script.gameObject.layer;

            Ray ray = HandleUtility.GUIPointToWorldRay(mousePos);
            RaycastHit hit;
            if (Physics.Raycast(ray, out hit, 1000f, backgroundLayerMask))
            {
                Vector3 hitPos = hit.point;
                TryAddConnection ( hitPos );
            }
        }
    }

#endregion

    
    
 

#region Line Points Setting Method
    void SetStraightLine()
    {
        // List<Vector3> wayPoints = script.pathData.points;
        // if (wayPoints.Count < 2)
        //     return;

        // for (int i = 0; i < wayPoints.Count-1; i++)
        // {
        //     for (float t = 0f; t <= 1.0f; t += 0.05f)
        //     {
        //         Vector3 pt = wayPoints[i] * (1f - t) + wayPoints[i + 1] * t;
        //         script.pathData.linePoints.Add(pt);
        //     }
        // }

        // script.pathData.linePoints.Add(wayPoints[wayPoints.Count - 1]);
    }

    void SetCatmullRomCurveLine()
    {
        // List<Vector3> wayPoints = script.pathData.points;

        // if (wayPoints.Count < 3)
        //     return;

        // Vector3[] catmullRomPoints = new Vector3[wayPoints.Count + 2];
        // wayPoints.CopyTo(catmullRomPoints, 1);

        // int endIndex = catmullRomPoints.Length - 1;

        // catmullRomPoints[0] = catmullRomPoints[1] + (catmullRomPoints[1] - catmullRomPoints[2]) + (catmullRomPoints[3] - catmullRomPoints[2]);
        // catmullRomPoints[endIndex] = catmullRomPoints[endIndex - 1] + (catmullRomPoints[endIndex - 1] - catmullRomPoints[endIndex - 2])
        //                         + (catmullRomPoints[endIndex - 3] - catmullRomPoints[endIndex - 2]);

        // script.pathData.linePoints.Add(wayPoints[0]);

        // for (int i = 0; i < catmullRomPoints.Length - 3; i++)
        // {
        //     for (float t = 0.05f; t <= 1.0f; t += 0.05f)
        //     {
        //         Vector3 pt = ComputeCatmullRom(catmullRomPoints[i], catmullRomPoints[i + 1], catmullRomPoints[i + 2], catmullRomPoints[i + 3], t);
        //         script.pathData.linePoints.Add(pt);
        //     }
        // }

        // script.pathData.linePoints.Add(wayPoints[wayPoints.Count - 1]);
    }

    Vector3 ComputeCatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
    {
        float t2 = t * t;
        float t3 = t2 * t;

        Vector3 pt = 0.5f * ((-p0 + 3f * p1 - 3f * p2 + p3) * t3
                    + (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2
                    + (-p0 + p2) * t
                    + 2f * p1);

        return pt;
    }

    void SetBezierCurveLine()
    {
        // List<Vector3> wayPoints = script.pathData.points;
        // List<Vector3> firstControls = script.pathData.firstHandles;
        // List<Vector3> secondControls = script.pathData.secondHandles;

        // if (wayPoints.Count < 2)
        //     return;

        // script.pathData.linePoints.Add(wayPoints[0]);

        // for (int i = 0; i < wayPoints.Count - 1; i++)
        // {
        //     Vector3 waypoint1 = wayPoints[i];
        //     Vector3 waypoint2 = wayPoints[i + 1];
        //     Vector3 controlPoint1 = wayPoints[i] + secondControls[i];
        //     Vector3 controlPoint2 = wayPoints[i + 1] + firstControls[i + 1];

        //     for (float t = 0.05f; t <= 1.0f; t += 0.05f)
        //     {
        //         Vector3 pt = ComputeBezier(waypoint1, controlPoint1, controlPoint2, waypoint2, t);

        //         script.pathData.linePoints.Add(pt);
        //     }
        // }

        // script.pathData.linePoints.Add(wayPoints[wayPoints.Count-1]);
    }

    Vector3 ComputeBezier(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
    {
        float t2 = t * t;
        float t3 = t * t * t;
        float _t2 = (1 - t) * (1 - t);
        float _t3 = (1 - t) * (1 - t) * (1 - t);

        return p0 * _t3 + 3f * p1 * t * _t2 + 3 * p2 * t2 * (1 - t) + p3 * t3;
    }

#endregion

#region Waypoint and WayPath Method

    void AddWaypoint(Vector3 position, int addIndex = -1)
    {
        if (addIndex == -1)
            script.pathData.points.Add( new WayPoint( position ));
        else
            script.pathData.points.Insert(addIndex, new WayPoint( position ));

        script.pathData.Refresh();
    }
	
    void DeleteWaypoint(int removeIndex = -1)
    {
        List<WayPoint> wayPointList = script.pathData.points;
        if (wayPointList == null || wayPointList.Count == 0)
            return;

        if (removeIndex == -1) removeIndex = wayPointList.Count - 1;
        wayPointList.RemoveAt(removeIndex);
        
        script.pathData.Refresh();
    }

    void ClearWaypoint()
    {
        script.pathData.points.Clear();
    }

	void AddWayPath( int addIndex = -1, int from = -1, int to = -1)
    {
		if ( from != -1 && to != -1 )
		{
			if ( from == to ) 
			{
				Debug.LogError("Error. Preventing from adding Path to the same node");
				return;
			}
			WayPath pd = script.pathData.GetPathBetween ( from, to );
			if ( pd != null ) 
			{
				Debug.LogError("Error. We already have a path between these nodes. Aborted");
				return;
			}
		}

        if (addIndex == -1)
			script.pathData.paths.Add( new WayPath( from, to ));
        else
            script.pathData.paths.Insert(addIndex, new WayPath( from, to ));

        // script.pathData.firstHandles.Add(Vector3.left);
        // script.pathData.secondHandles.Add(Vector3.right);
        script.pathData.Refresh();
    }

    void DeleteWayPath(int removeIndex = -1)
    {
        List<WayPath> wayPathList = script.pathData.paths;
        if (wayPathList == null || wayPathList.Count == 0)
            return;

        if (removeIndex == -1) removeIndex = wayPathList.Count - 1;
        wayPathList.RemoveAt(removeIndex);
        // script.pathData.firstHandles.RemoveAt(removeIndex);
        // script.pathData.secondHandles.RemoveAt(removeIndex);
        script.pathData.Refresh();
    }

     void ClearWayPath()
    {
        script.pathData.paths.Clear();
        // script.pathData.firstHandles.Clear();
        // script.pathData.secondHandles.Clear();
    }

    void TryAddConnection(Vector3 position )
    {
        WayPoint selectedPoint =  script.pathData.GetWayPoint( script.FindNearestWayPoint ( position ) );

        if ( selectedPoint == null )
        {
            Debug.LogError("ERROR. could not find any nearest point");
			return;
        }

        if ( selectedPointForConnectPointsMode != -1 ) 
        {
			AddWayPath ( -1, selectedPointForConnectPointsMode, selectedPoint.autoGeneratedID ) ;
			selectedPointForConnectPointsMode = -1;
        }
        else 
        {
			selectedPointForConnectPointsMode = selectedPoint.autoGeneratedID;
        }

    }

   


#endregion

#region Path finding 

   

#endregion

    private int selectedPointForConnectPointsMode = -1;
    private bool showPointIDsInTheScene = true;
    private bool showPathIDsInTheScene = true;
    private bool showCostsInTheScene = false;
    private bool showDefaultInspector = false;
}
