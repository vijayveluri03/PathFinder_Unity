using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Mr1;

namespace Mr1
{
    public class WaypointManager : MonoBehaviour
    {
        static WaypointManager _instance;
        public static WaypointManager instance { get { return _instance; } }

        public GraphData graphData = new GraphData();
        
        public void Awake()
        {
            _instance = this;
        }
        public void OnDestroy ()
        {
            _instance = null;
        }


        public void FindShortestPathAsynchronous ( int fromNodeID, int toNodeId, System.Action<List<Node>> callback )
        {
            StartCoroutine( FindShortestPathAsynchonousInternal( fromNodeID, toNodeId, callback ) );
        }

        public List<Node> FindShortedPath( int fromNodeID, int toNodeID )
        {
            int startPointID = fromNodeID; 
            int endPointID = toNodeID;
            bool found = false;

            graphData.Refresh();

            Node startPoint = graphData.nodesSorted[startPointID];
            Node endPoint = graphData.nodesSorted[endPointID];

            foreach( var point in graphData.nodes )
            {
                point.HeuristicDistance = -1;
                point.previousWayPoint = null;
            }

            List<Node> completedPoints = new List<Node>();
            List<Node> nextPoints = new List<Node>();
            List<Node> finalPath = new List<Node>();

            startPoint.pathDistance = 0;
            startPoint.HeuristicDistance = Vector3.Distance ( startPoint.position, endPoint.position );
            nextPoints.Add( startPoint );

            while ( true )
            {
                Node leastCostPoint = null; 
                
                float minCost = 99999;
                foreach ( var point in nextPoints )
                {
                    if ( point.HeuristicDistance <= 0 )
                        point.HeuristicDistance = Vector3.Distance ( point.position, endPoint.position );

                    if ( minCost > point.combinedHeuristic )
                    {
                        leastCostPoint = point;
                        minCost = point.combinedHeuristic;
                    }
                }

                if ( leastCostPoint == null ) 
                    break;
                
                if ( leastCostPoint == endPoint )
                {
                    found = true;
                    Node prevPoint = leastCostPoint;
                    while ( prevPoint != null ) 
                    {
                        finalPath.Insert(0, prevPoint);
                        prevPoint = prevPoint.previousWayPoint;
                    }

                    return finalPath;
                }
    
                foreach ( var path in graphData.paths )
                {
                    if ( path.IDOfA == leastCostPoint.autoGeneratedID 
                    || path.IDOfB == leastCostPoint.autoGeneratedID )
                    {
                        Node otherPoint = path.IDOfA == leastCostPoint.autoGeneratedID ? 
                                                graphData.nodesSorted[path.IDOfB] : graphData.nodesSorted[path.IDOfA];

                        if ( otherPoint.HeuristicDistance <= 0 )
                            otherPoint.HeuristicDistance = Vector3.Distance ( otherPoint.position, endPoint.position );

                        if ( completedPoints.Contains ( otherPoint) )
                            continue;

                        if ( nextPoints.Contains( otherPoint ))
                        {
                            if ( otherPoint.pathDistance > 
                                ( leastCostPoint.pathDistance + path.cost ) )
                            {
                                otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                                otherPoint.previousWayPoint = leastCostPoint;
                            }
                        }
                        else
                        {
                            otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                            otherPoint.previousWayPoint = leastCostPoint;
                            nextPoints.Add ( otherPoint );
                        }
                    }
                }

                nextPoints.Remove ( leastCostPoint );
                completedPoints.Add ( leastCostPoint );
            }       

            if ( !found ) 
            {
                return null;
            }
            Debug.LogError("Shouldnt be here");
            return null;
        }


        IEnumerator FindShortestPathAsynchonousInternal ( int fromNodeID, int toNodeID, System.Action<List<Node>> callback )
        {
            if ( callback == null )
                yield break;

            int startPointID = fromNodeID; 
            int endPointID = toNodeID;
            bool found = false;

            graphData.Refresh();

            Node startPoint = graphData.nodesSorted[startPointID];
            Node endPoint = graphData.nodesSorted[endPointID];

            foreach( var point in graphData.nodes )
            {
                point.HeuristicDistance = -1;
                point.previousWayPoint = null;
            }

            List<Node> completedPoints = new List<Node>();
            List<Node> nextPoints = new List<Node>();
            List<Node> finalPath = new List<Node>();

            startPoint.pathDistance = 0;
            startPoint.HeuristicDistance = Vector3.Distance ( startPoint.position, endPoint.position );
            nextPoints.Add( startPoint );

            while ( true )
            {
                Node leastCostPoint = null; 
                
                float minCost = 99999;
                foreach ( var point in nextPoints )
                {
                    if ( point.HeuristicDistance <= 0 )
                        point.HeuristicDistance = Vector3.Distance ( point.position, endPoint.position );

                    if ( minCost > point.combinedHeuristic )
                    {
                        leastCostPoint = point;
                        minCost = point.combinedHeuristic;
                    }
                }

                if ( leastCostPoint == null ) 
                    break;
                
                if ( leastCostPoint == endPoint )
                {
                    found = true;
                    Node prevPoint = leastCostPoint;
                    while ( prevPoint != null ) 
                    {
                        finalPath.Insert(0, prevPoint);
                        prevPoint = prevPoint.previousWayPoint;
                    }

                    callback ( finalPath );
                    yield break;
                }
    
                foreach ( var path in graphData.paths )
                {
                    if ( path.IDOfA == leastCostPoint.autoGeneratedID 
                    || path.IDOfB == leastCostPoint.autoGeneratedID )
                    {
                        Node otherPoint = path.IDOfA == leastCostPoint.autoGeneratedID ? 
                                                graphData.nodesSorted[path.IDOfB] : graphData.nodesSorted[path.IDOfA];

                        if ( otherPoint.HeuristicDistance <= 0 )
                            otherPoint.HeuristicDistance = Vector3.Distance ( otherPoint.position, endPoint.position );

                        if ( completedPoints.Contains ( otherPoint) )
                            continue;

                        if ( nextPoints.Contains( otherPoint ))
                        {
                            if ( otherPoint.pathDistance > 
                                ( leastCostPoint.pathDistance + path.cost ) )
                            {
                                otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                                otherPoint.previousWayPoint = leastCostPoint;
                            }
                        }
                        else
                        {
                            otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                            otherPoint.previousWayPoint = leastCostPoint;
                            nextPoints.Add ( otherPoint );
                        }
                    }
                }

                nextPoints.Remove ( leastCostPoint );
                completedPoints.Add ( leastCostPoint );

                yield return null;
            }       

            if ( !found ) 
            {
                callback ( null );
                yield break;
            }
            
            Debug.LogError("Shouldnt be here");
            callback ( null );
            yield break;
        }

        public int FindNearestNode ( Vector3 point )
		{
			float minDistance = float.MaxValue;
			Node nearestWayPoint = null;

			foreach ( var wayPoint in graphData.nodes )
			{
				if ( Vector3.Distance ( wayPoint.position, point ) < minDistance ) 
				{
					minDistance = Vector3.Distance ( wayPoint.position, point );
					nearestWayPoint = wayPoint;
				}
			}

			return nearestWayPoint != null ? nearestWayPoint.autoGeneratedID : -1;
		}

        

    }
}
