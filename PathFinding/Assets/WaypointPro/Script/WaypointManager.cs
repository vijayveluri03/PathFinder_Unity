using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Mr1;

namespace Mr1
{
    public class WaypointManager : MonoBehaviour
    {
        static WaypointManager _instance;
        public static WaypointManager instance { get { if (_instance == null) { _instance = GameObject.FindObjectOfType<WaypointManager>(); _instance.Init(); } return _instance; } }
        public PathData selected { get; set; }

        public List<PathData> pathList = new List<PathData>();
        Dictionary<string, PathData> _pathDic;

        void Init()
        {
            //GetComponent<Collider>().enabled = false;
            _pathDic = new Dictionary<string, PathData>(pathList.Count);
            for (int i = 0; i < pathList.Count; ++i) _pathDic.Add(pathList[i].pathName, pathList[i]);
        }

		public void SelectPath ( int pathIndex ) 
		{
			if ( pathList != null && pathList.Count > pathIndex )
			{
				selected = pathList[pathIndex];
				selected.Refresh();
			}
		}

        public PathData GetPathData(string pathName)
        {
            if (_pathDic.ContainsKey(pathName)) return _pathDic[pathName];
            return null;
        }

        public void FindShortestPathAsynchronous ( int fromNodeID, int toNodeId, System.Action<List<WayPoint>> callback )
        {
            StartCoroutine( FindShortestPathAsynchonousInternal( fromNodeID, toNodeId, callback ) );
        }

        public List<WayPoint> FindShortedPath( int fromNodeID, int toNodeID )
        {
            int startPointID = fromNodeID; 
            int endPointID = toNodeID;
            bool found = false;

            selected.Refresh();

            WayPoint startPoint = selected.pointsSorted[startPointID];
            WayPoint endPoint = selected.pointsSorted[endPointID];

            foreach( var point in selected.points )
            {
                point.HeuristicDistance = -1;
                point.previousWayPoint = null;
            }

            List<WayPoint> completedPoints = new List<WayPoint>();
            List<WayPoint> nextPoints = new List<WayPoint>();
            List<WayPoint> finalPath = new List<WayPoint>();

            startPoint.pathDistance = 0;
            startPoint.HeuristicDistance = Vector3.Distance ( startPoint.position, endPoint.position );
            nextPoints.Add( startPoint );

            while ( true )
            {
                WayPoint leastCostPoint = null; 
                
                float minCost = 99999;
                foreach ( var point in nextPoints )
                {
                    if ( point.HeuristicDistance <= 0 )
                        point.HeuristicDistance = Vector3.Distance ( point.position, endPoint.position );

                    if ( minCost > point.combinedHeuristic )
                    {
                        leastCostPoint = point;
                        minCost = point.combinedHeuristic;
                    }
                }

                if ( leastCostPoint == null ) 
                    break;
                
                if ( leastCostPoint == endPoint )
                {
                    found = true;
                    WayPoint prevPoint = leastCostPoint;
                    while ( prevPoint != null ) 
                    {
                        finalPath.Insert(0, prevPoint);
                        prevPoint = prevPoint.previousWayPoint;
                    }

                    return finalPath;
                }
    
                foreach ( var path in selected.paths )
                {
                    if ( path.IDOfA == leastCostPoint.autoGeneratedID 
                    || path.IDOfB == leastCostPoint.autoGeneratedID )
                    {
                        WayPoint otherPoint = path.IDOfA == leastCostPoint.autoGeneratedID ? 
                                                selected.pointsSorted[path.IDOfB] : selected.pointsSorted[path.IDOfA];

                        if ( otherPoint.HeuristicDistance <= 0 )
                            otherPoint.HeuristicDistance = Vector3.Distance ( otherPoint.position, endPoint.position );

                        if ( completedPoints.Contains ( otherPoint) )
                            continue;

                        if ( nextPoints.Contains( otherPoint ))
                        {
                            if ( otherPoint.pathDistance > 
                                ( leastCostPoint.pathDistance + path.cost ) )
                            {
                                otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                                otherPoint.previousWayPoint = leastCostPoint;
                            }
                        }
                        else
                        {
                            otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                            otherPoint.previousWayPoint = leastCostPoint;
                            nextPoints.Add ( otherPoint );
                        }
                    }
                }

                nextPoints.Remove ( leastCostPoint );
                completedPoints.Add ( leastCostPoint );
            }       

            if ( !found ) 
            {
                return null;
            }
            Debug.LogError("Shouldnt be here");
            return null;
        }


        IEnumerator FindShortestPathAsynchonousInternal ( int fromNodeID, int toNodeID, System.Action<List<WayPoint>> callback )
        {
            if ( callback == null )
                yield break;

            int startPointID = fromNodeID; 
            int endPointID = toNodeID;
            bool found = false;

            selected.Refresh();

            WayPoint startPoint = selected.pointsSorted[startPointID];
            WayPoint endPoint = selected.pointsSorted[endPointID];

            foreach( var point in selected.points )
            {
                point.HeuristicDistance = -1;
                point.previousWayPoint = null;
            }

            List<WayPoint> completedPoints = new List<WayPoint>();
            List<WayPoint> nextPoints = new List<WayPoint>();
            List<WayPoint> finalPath = new List<WayPoint>();

            startPoint.pathDistance = 0;
            startPoint.HeuristicDistance = Vector3.Distance ( startPoint.position, endPoint.position );
            nextPoints.Add( startPoint );

            while ( true )
            {
                WayPoint leastCostPoint = null; 
                
                float minCost = 99999;
                foreach ( var point in nextPoints )
                {
                    if ( point.HeuristicDistance <= 0 )
                        point.HeuristicDistance = Vector3.Distance ( point.position, endPoint.position );

                    if ( minCost > point.combinedHeuristic )
                    {
                        leastCostPoint = point;
                        minCost = point.combinedHeuristic;
                    }
                }

                if ( leastCostPoint == null ) 
                    break;
                
                if ( leastCostPoint == endPoint )
                {
                    found = true;
                    WayPoint prevPoint = leastCostPoint;
                    while ( prevPoint != null ) 
                    {
                        finalPath.Insert(0, prevPoint);
                        prevPoint = prevPoint.previousWayPoint;
                    }

                    callback ( finalPath );
                    yield break;
                }
    
                foreach ( var path in selected.paths )
                {
                    if ( path.IDOfA == leastCostPoint.autoGeneratedID 
                    || path.IDOfB == leastCostPoint.autoGeneratedID )
                    {
                        WayPoint otherPoint = path.IDOfA == leastCostPoint.autoGeneratedID ? 
                                                selected.pointsSorted[path.IDOfB] : selected.pointsSorted[path.IDOfA];

                        if ( otherPoint.HeuristicDistance <= 0 )
                            otherPoint.HeuristicDistance = Vector3.Distance ( otherPoint.position, endPoint.position );

                        if ( completedPoints.Contains ( otherPoint) )
                            continue;

                        if ( nextPoints.Contains( otherPoint ))
                        {
                            if ( otherPoint.pathDistance > 
                                ( leastCostPoint.pathDistance + path.cost ) )
                            {
                                otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                                otherPoint.previousWayPoint = leastCostPoint;
                            }
                        }
                        else
                        {
                            otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost; 
                            otherPoint.previousWayPoint = leastCostPoint;
                            nextPoints.Add ( otherPoint );
                        }
                    }
                }

                nextPoints.Remove ( leastCostPoint );
                completedPoints.Add ( leastCostPoint );

                yield return null;
            }       

            if ( !found ) 
            {
                callback ( null );
                yield break;
            }
            
            Debug.LogError("Shouldnt be here");
            callback ( null );
            yield break;
        }

        public static List<Vector3> GetStraightPathPoints( List<WayPoint> points )
        {
            if ( points == null )
                return null;

            List<WayPoint> wayPoints = points;
            List<Vector3> path = new List<Vector3>();
            
            if (wayPoints.Count < 2)
            {
                return null;
            }

            for (int i = 0; i < wayPoints.Count-1; i++)
            {
                for (float t = 0f; t <= 1.0f; t += 0.05f)
                {
                    Vector3 pt = wayPoints[i].position * (1f - t) + wayPoints[i + 1].position * t;
                    path.Add(pt);
                }
            }

            path.Add(wayPoints[wayPoints.Count - 1].position);
            return path;
        }

        public static List<Vector3> GetCatmullRomCurvePathPoints( List<WayPoint> points )
        {
            if ( points == null )
                return null;

            List<WayPoint> wayPoints = points;
            List<Vector3> path = new List<Vector3>();
            
            if (wayPoints.Count < 3)
            {
                for( int i = 0; i < wayPoints.Count; i++ )
                {
                    path.Add (wayPoints[i].position );
                }
                return path;
            }

            Vector3[] catmullRomPoints = new Vector3[wayPoints.Count + 2];
            for( int i = 0; i < wayPoints.Count; i++ )
            {
                catmullRomPoints[i+1] = wayPoints[i].position;
            }
            int endIndex = catmullRomPoints.Length - 1;

            catmullRomPoints[0] = catmullRomPoints[1] + (catmullRomPoints[1] - catmullRomPoints[2]) + (catmullRomPoints[3] - catmullRomPoints[2]);
            catmullRomPoints[endIndex] = catmullRomPoints[endIndex - 1] + (catmullRomPoints[endIndex - 1] - catmullRomPoints[endIndex - 2])
                                    + (catmullRomPoints[endIndex - 3] - catmullRomPoints[endIndex - 2]);

            path.Add(wayPoints[0].position);

            for (int i = 0; i < catmullRomPoints.Length - 3; i++)
            {
                for (float t = 0.05f; t <= 1.0f; t += 0.05f)
                {
                    Vector3 pt = ComputeCatmullRom(catmullRomPoints[i], catmullRomPoints[i + 1], catmullRomPoints[i + 2], catmullRomPoints[i + 3], t);
                    path.Add(pt);
                }
            }

            path.Add(wayPoints[wayPoints.Count - 1].position);
            return path;
        }
        public static Vector3 ComputeCatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
        {
            float t2 = t * t;
            float t3 = t2 * t;

            Vector3 pt = 0.5f * ((-p0 + 3f * p1 - 3f * p2 + p3) * t3
                        + (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2
                        + (-p0 + p2) * t
                        + 2f * p1);

            return pt;
        }


    }
}
